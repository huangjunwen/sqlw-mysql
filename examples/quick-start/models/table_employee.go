// Auto generated by sqlw-mysql (https://github.com/huangjunwen/sqlw-mysql) default template.
// DON NOT EDIT.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"gopkg.in/volatiletech/null.v6"
)

// Employee represents a row of table `employee`.
type Employee struct {
	Id         int32      `json:"id" db:"id"`
	EmployeeSn string     `json:"employee_sn" db:"employee_sn"`
	UserId     int32      `json:"user_id" db:"user_id"`
	SuperiorId null.Int32 `json:"superior_id" db:"superior_id"`
}

// nxEmployeePrimaryValue is the primary value of Employee.
type nxEmployeePrimaryValue struct {
	Id int32
}

// nxNullEmployee is nullable version of Employee.
// It's mainly used for scanning row which maybe NULL (e.g. in outer join).
type nxNullEmployee struct {
	ordinary       *Employee
	nxEmployee     Employee
	nullId         null.Int32  // For scanning column `id`
	nullEmployeeSn null.String // For scanning column `employee_sn`
	nullUserId     null.Int32  // For scanning column `user_id`
}

// EmployeeSlice is slice of Employee.
type EmployeeSlice []*Employee

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *Employee) nxPreScan(dest *[]interface{}) {
	*dest = append(*dest,
		&tr.Id,
		&tr.EmployeeSn,
		&tr.UserId,
		&tr.SuperiorId,
	)
}

// nxPostScan do nothing. Implements ColumnScanner interface.
func (tr *Employee) nxPostScan() error {
	return nil
}

var (
	nxEmployeeMeta = NewTableMeta(
		"employee",
		[]string{"id", "employee_sn", "user_id", "superior_id"},
		OptColumnsWithDefault("id"),
		OptPrimaryColumns("id"),
		OptAutoIncColumn("id"),
	)
)

// TableMeta returns the table meta information of table `employee`. Implements TableRow interface.
func (tr *Employee) TableMeta() *TableMeta {
	return nxEmployeeMeta
}

// Valid returns true if this is a valid table row (e.g. not NULL). Implements TableRow interface.
func (tr *Employee) Valid() bool {
	return tr != nil
}

// ColumnValue returns the i-th column's value. Implements TableRow interface.
func (tr *Employee) ColumnValue(i int) interface{} {
	switch i {
	case 0:
		return tr.Id
	case 1:
		return tr.EmployeeSn
	case 2:
		return tr.UserId
	case 3:
		return tr.SuperiorId
	default:
		panic(fmt.Errorf("Employee.ColumnValue: %d out of range", i))
	}
}

// ColumnPointer returns the i-th column's pointer. Implements TableRow interface.
func (tr *Employee) ColumnPointer(i int) interface{} {
	switch i {
	case 0:
		return &tr.Id
	case 1:
		return &tr.EmployeeSn
	case 2:
		return &tr.UserId
	case 3:
		return &tr.SuperiorId
	default:
		panic(fmt.Errorf("Employee.ColumnPointer: %d out of range", i))
	}
}

// Copy the row.
func (tr *Employee) Copy() *Employee {
	ret := &Employee{}
	*ret = *tr
	return ret
}

// PrimaryValue returns the primary key value of this row. Implements TableRowWithPrimary interface.
func (tr *Employee) PrimaryValue() interface{} {
	if tr == nil {
		return nil
	}
	return nxEmployeePrimaryValue{
		Id: tr.Id,
	}
}

// Insert is used to insert the row into table.
// This method will also update the value in auto increment column (if exists).
func (tr *Employee) Insert(ctx context.Context, e Execer) error {
	return insertTR(ctx, e, tr, "")
}

// InsertEx is the same as Insert with extra modifier specified.
// modifier can be one of:
//   - "ignore": "INSERT IGNORE INTO ..."
//   - "replace": "REPLACE INTO ..."
//   - "": Normal "INSERT INTO ..."
func (tr *Employee) InsertEx(ctx context.Context, e Execer, modifier string) error {
	return insertTR(ctx, e, tr, modifier)
}

// Reload is used to reload the row from table. It returns error if no row is found.
func (tr *Employee) Reload(ctx context.Context, q Queryer) error {
	return selectTR(ctx, q, tr, false)
}

// ReloadWithLock is used to reload this row with lock from table. It returns error if no row is found.
func (tr *Employee) ReloadWithLock(ctx context.Context, q Queryer) error {
	return selectTR(ctx, q, tr, true)
}

// Update is used to update the row in table. Only columns with different values will be updated.
// NOTE: This method does not modify content in `tr`/`newTr`. Use Reload to load fresh data from database.
func (tr *Employee) Update(ctx context.Context, e Execer, newTr *Employee) error {
	return updateTR(ctx, e, tr, newTr)
}

// Delete is used to delete the row from table.
func (tr *Employee) Delete(ctx context.Context, e Execer) error {
	return deleteTR(ctx, e, tr)
}

// EmployeeByFkSuperior returns the associated Employee by `fk_superior` foreign key: (`superior_id`).
func (tr *Employee) EmployeeByFkSuperior(ctx context.Context, q Queryer, lock bool) (*Employee, error) {

	if !tr.SuperiorId.Valid {
		return nil, nil
	}
	nxSuperiorId := tr.SuperiorId.Int32

	return EmployeeByPrimary(ctx, q, nxSuperiorId, lock)
}

// UserByFkUser returns the associated User by `fk_user` foreign key: (`user_id`).
func (tr *Employee) UserByFkUser(ctx context.Context, q Queryer, lock bool) (*User, error) {

	nxUserId := tr.UserId

	return UserByPrimary(ctx, q, nxUserId, lock)
}

// EmployeeByEmployeeSn is used to select Employee by `employee_sn` index.
// It returns nil if no row is found.
func EmployeeByEmployeeSn(ctx context.Context, q Queryer, nxEmployeeSn string, lock bool) (*Employee, error) {
	tr := Employee{}
	if err := selectTRCond(ctx, q, &tr, lock, "1 AND `employee_sn`=?", nxEmployeeSn); err != nil {
		if err == sql.ErrNoRows {
			err = nil
		}
		return nil, err
	}
	return &tr, nil
}

// EmployeeByPrimary is used to select Employee by `PRIMARY` index.
// It returns nil if no row is found.
func EmployeeByPrimary(ctx context.Context, q Queryer, nxId int32, lock bool) (*Employee, error) {
	tr := Employee{}
	if err := selectTRCond(ctx, q, &tr, lock, "1 AND `id`=?", nxId); err != nil {
		if err == sql.ErrNoRows {
			err = nil
		}
		return nil, err
	}
	return &tr, nil
}

// EmployeeByUserId is used to select Employee by `user_id` index.
// It returns nil if no row is found.
func EmployeeByUserId(ctx context.Context, q Queryer, nxUserId int32, lock bool) (*Employee, error) {
	tr := Employee{}
	if err := selectTRCond(ctx, q, &tr, lock, "1 AND `user_id`=?", nxUserId); err != nil {
		if err == sql.ErrNoRows {
			err = nil
		}
		return nil, err
	}
	return &tr, nil
}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *nxNullEmployee) nxPreScan(dest *[]interface{}) {
	*dest = append(*dest,
		&tr.nullId,
		&tr.nullEmployeeSn,
		&tr.nullUserId,
		&tr.nxEmployee.SuperiorId,
	)
}

// nxPostScan must be called after scanning to do some extra processsing. Implements ColumnScanner interface.
func (tr *nxNullEmployee) nxPostScan() error {

	var nullCol string

	if !tr.nullId.Valid {
		nullCol = "id"
		goto CheckNULL
	}
	tr.nxEmployee.Id = tr.nullId.Int32

	if !tr.nullEmployeeSn.Valid {
		nullCol = "employee_sn"
		goto CheckNULL
	}
	tr.nxEmployee.EmployeeSn = tr.nullEmployeeSn.String

	if !tr.nullUserId.Valid {
		nullCol = "user_id"
		goto CheckNULL
	}
	tr.nxEmployee.UserId = tr.nullUserId.Int32

	if false {
		// NOTE: Impossible branch to suppress "label CheckNULL defined and not used" error.
		goto CheckNULL
	}

	// All checks passed
	tr.ordinary = &tr.nxEmployee
	return nil

CheckNULL:
	if *tr == (nxNullEmployee{}) {
		// Null row, set ptr to nil.
		tr.ordinary = nil
		return nil
	}
	return fmt.Errorf("employee.%s can't be NULL", nullCol)
}

// Ordinary returns the ordinary Employee. It must be called only after nxPostScan.
func (tr *nxNullEmployee) Ordinary() *Employee {
	return tr.ordinary
}

func (slice *EmployeeSlice) nxLen() int {
	return len(*slice)
}

func (slice *EmployeeSlice) nxItem(i int) interface{} {
	return (*slice)[i]
}

func (slice *EmployeeSlice) nxAppend(item interface{}) {
	if item == nil {
		*slice = append(*slice, &Employee{})
	} else {
		*slice = append(*slice, item.(*Employee))
	}
}

// Suppress not used errors.
var (
	_ = context.Background
	_ = fmt.Printf
	_ = strings.Join
	_ = time.Now
	_ = sql.Drivers
	_ = null.NewBool
)

var (
	_ TableRow            = (*Employee)(nil)
	_ TableRowWithPrimary = (*Employee)(nil)
	_ ColumnScanner       = (*nxNullEmployee)(nil)
	_ Slicer              = (*EmployeeSlice)(nil)
)
