// Auto generated by sqlw-mysql (https://github.com/huangjunwen/sqlw-mysql) default template.
// DON NOT EDIT.

package {{ .PackageName }}


import (
  "context"
  "fmt"
  "strings"
  "time"
  "database/sql"

  "gopkg.in/volatiletech/null.v6"
)

{{ $tableName := .Table.TableName }}
{{ $camelName := .Table.CamelName }}
{{ $primary := .Table.Primary }}

// {{ $camelName }} represents a row of table `{{ $tableName }}`.
type {{ $camelName }} struct {
  {{ range .Table.Columns -}}
    {{ .CamelName }} {{ scanType . }} `json:"{{ .ColumnName }}" db:"{{ .ColumnName }}"` 
  {{ end -}}
}

{{ if $primary.Valid -}}
// nx{{ $camelName }}PrimaryValue is the primary value of {{ $camelName }}.
type nx{{ $camelName }}PrimaryValue struct {
  {{ range $primary.Columns -}}
    {{ .CamelName }} {{ scanType . }}
  {{ end -}}
}
{{ end }}

// nxNull{{ $camelName }} is nullable version of {{ $camelName }}. 
// It's mainly used for scanning row which maybe NULL (e.g. in outer join).
type nxNull{{ $camelName }} struct {
  ordinary *{{ $camelName }}
  nx{{ $camelName }} {{ $camelName }}
  {{ range .Table.Columns -}}
    {{ if not .Nullable -}}
      null{{ .CamelName }} {{ nullScanType . }} // For scanning column `{{ .ColumnName }}`
    {{ end -}}
  {{ end -}}
}

// {{ $camelName }}Slice is slice of {{ $camelName }}.
type {{ $camelName }}Slice []*{{ $camelName }}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *{{ $camelName }}) nxPreScan(dest *[]interface{}) {
  *dest = append(*dest,
  {{ range .Table.Columns -}}
    &tr.{{ .CamelName }},
  {{ end -}}
  )
}

// nxPostScan do nothing. Implements ColumnScanner interface.
func (tr *{{ $camelName }}) nxPostScan() error { 
  return nil 
}

var (
  nx{{ $camelName }}Meta = NewTableMeta(
    "{{ $tableName }}",
    []string{ {{- range .Table.Columns }}"{{ .ColumnName }}", {{ end -}} },
    OptColumnsWithDefault({{ range .Table.Columns }}{{ if .HasDefaultValue }}"{{ .ColumnName }}", {{ end }}{{ end }}),
    {{ if $primary.Valid -}}
      OptPrimaryColumns({{ range $primary.Columns }}"{{ .ColumnName }}", {{ end }}),
    {{ end -}}
    {{ if .Table.AutoIncColumn.Valid -}}
      OptAutoIncColumn("{{ .Table.AutoIncColumn.ColumnName }}"),
    {{ end -}}
  )
)

// TableMeta returns the table meta information of table `{{ $tableName }}`. Implements TableRow interface.
func (tr *{{ $camelName }}) TableMeta() *TableMeta {
  return nx{{ $camelName }}Meta
}

// Valid returns true if this is a valid table row (e.g. not NULL). Implements TableRow interface.
func (tr *{{ $camelName }}) Valid() bool {
  return tr != nil
}

// ColumnValue returns the i-th column's value. Implements TableRow interface.
func (tr *{{ $camelName }}) ColumnValue(i int) interface{} {
  switch i {
  {{ range $i, $col := .Table.Columns -}}
  case {{ $i }}:
    return tr.{{ $col.CamelName }}
  {{ end -}}
  default:
    panic(fmt.Errorf("{{ $camelName }}.ColumnValue: %d out of range", i))
  }
}

// ColumnPointer returns the i-th column's pointer. Implements TableRow interface.
func (tr *{{ $camelName }}) ColumnPointer(i int) interface{} {
  switch i {
  {{ range $i, $col := .Table.Columns -}}
  case {{ $i }}:
    return &tr.{{ $col.CamelName }}
  {{ end -}}
  default:
    panic(fmt.Errorf("{{ $camelName }}.ColumnPointer: %d out of range", i))
  }
}

// Copy the row.
func (tr *{{ $camelName }}) Copy() *{{ $camelName }} {
  ret := &{{ $camelName }}{}
  *ret = *tr
  return ret
}

{{ if $primary.Valid -}}
  // PrimaryValue returns the primary key value of this row. Implements TableRowWithPrimary interface.
  func (tr *{{ $camelName }}) PrimaryValue() interface{} {
    if tr == nil {
      return nil
    }
    return nx{{ $camelName }}PrimaryValue{
      {{ range $primary.Columns -}}
        {{ .CamelName }}: tr.{{ .CamelName }},
      {{ end -}}
    }
  }
{{ end -}}

// Insert is used to insert the row into table.
// This method will also update the value in auto increment column (if exists).
func (tr *{{ $camelName }}) Insert(ctx context.Context, e Execer) error {
  return insertTR(ctx, e, tr, "")
}

// InsertEx is the same as Insert with extra modifier specified.
// modifier can be one of:
//   - "ignore": "INSERT IGNORE INTO ..."
//   - "replace": "REPLACE INTO ..."
//   - "": Normal "INSERT INTO ..."
func (tr *{{ $camelName }}) InsertEx(ctx context.Context, e Execer, modifier string) error {
  return insertTR(ctx, e, tr, modifier)
}

{{ if $primary.Valid -}}
  // Reload is used to reload the row from table. It returns error if no row is found.
  func (tr *{{ $camelName }}) Reload(ctx context.Context, q Queryer) error {
    return selectTR(ctx, q, tr, false)
  }
{{ end }}

{{ if $primary.Valid -}}
  // ReloadWithLock is used to reload this row with lock from table. It returns error if no row is found.
  func (tr *{{ $camelName }}) ReloadWithLock(ctx context.Context, q Queryer) error {
    return selectTR(ctx, q, tr, true)
  }
{{ end }}

{{ if $primary.Valid -}}
  // Update is used to update the row in table. Only columns with different values will be updated.
  // NOTE: This method does not modify content in `tr`/`newTr`. Use Reload to load fresh data from database.
  func (tr *{{ $camelName }}) Update(ctx context.Context, e Execer, newTr *{{ $camelName }}) error {
    return updateTR(ctx, e, tr, newTr)
  }
{{ end }}

{{ if $primary.Valid -}}
  // Delete is used to delete the row from table.
  func (tr *{{ $camelName }}) Delete(ctx context.Context, e Execer) error {
    return deleteTR(ctx, e, tr)
  }
{{ end }}

{{ range .Table.FKs -}}

  {{ $refTable := .RefTable -}}
  {{ $refIndex := .RefUniqueIndex -}}

  {{ if $refIndex.Valid -}}

    // {{ $refTable.CamelName }}By{{ .CamelName }} returns the associated {{ $refTable.CamelName }} by `{{ .FKName }}` foreign key: ({{ range $i, $col := .Columns }}{{ if ne $i 0 }},{{ end }}`{{ $col.ColumnName }}`{{ end }}).
    func (tr *{{ $camelName }}) {{ $refTable.CamelName }}By{{ .CamelName }}(ctx context.Context, q Queryer, lock bool) (*{{ $refTable.CamelName }}, error) {

      {{ range .Columns -}}
        {{ if .Nullable -}}
          if !tr.{{ .CamelName }}.Valid {
            return nil, nil
          } 
          nx{{ .CamelName }} := tr.{{ .CamelName }}.{{ substr 5 -1 (nullScanType .) }}
        {{ else -}}
          nx{{ .CamelName }} := tr.{{ .CamelName }}
        {{ end -}}
      {{ end }}

      return {{ $refTable.CamelName }}By{{ $refIndex.CamelName }}(ctx, q{{ range .Columns }}, nx{{ .CamelName }}{{ end }}, lock)
    }
  {{ end -}}

{{ end -}}

{{ range .Table.Indices -}}

  {{ if .IsUnique -}}

    // {{ $camelName }}By{{ .CamelName }} is used to select {{ $camelName }} by `{{ .IndexName }}` index.
    // It returns nil if no row is found.
    func {{ $camelName }}By{{ .CamelName }}(ctx context.Context, q Queryer{{ range .Columns }}, nx{{ .CamelName }} {{ notNullScanType . }}{{ end }}, lock bool) (*{{ $camelName }}, error){
      tr := {{ $camelName }}{}
      if err := selectTRCond(ctx, q, &tr, lock, "1{{ range .Columns }} AND `{{ .ColumnName }}`=?{{ end }}",
        {{- range .Columns -}}
          nx{{ .CamelName }},
        {{- end -}}
      ); err != nil {
        if err == sql.ErrNoRows {
          err = nil
        }
        return nil, err
      }
      return &tr, nil
    }

  {{ end -}}

{{ end }}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *nxNull{{ $camelName }}) nxPreScan(dest *[]interface{}) {
  *dest = append(*dest,
  {{ range .Table.Columns -}}
    {{ if .Nullable -}}
      &tr.nx{{ $camelName }}.{{ .CamelName }},
    {{ else -}}
      &tr.null{{ .CamelName }},
    {{ end -}}
  {{ end -}}
  )
}

// nxPostScan must be called after scanning to do some extra processsing. Implements ColumnScanner interface.
func (tr *nxNull{{ $camelName }}) nxPostScan() error {

  var nullCol string

  {{ range .Table.Columns -}}
    {{ if not .Nullable -}}
      if !tr.null{{ .CamelName }}.Valid {
        nullCol = "{{ .ColumnName }}"
        goto CheckNULL
      }
      tr.nx{{ $camelName }}.{{ .CamelName }} = tr.null{{ .CamelName }}.{{ substr 5 -1 (nullScanType .) }}

    {{ end -}}
  {{ end -}}

  if false {
    // NOTE: Impossible branch to suppress "label CheckNULL defined and not used" error.
    goto CheckNULL
  }

  // All checks passed
  tr.ordinary = &tr.nx{{ $camelName }}
  return nil

CheckNULL:
  if *tr == (nxNull{{ $camelName }}{}) {
    // Null row, set ptr to nil.
    tr.ordinary = nil
    return nil
  }
  return fmt.Errorf("{{ $tableName }}.%s can't be NULL", nullCol)
}


// Ordinary returns the ordinary {{ $camelName }}. It must be called only after nxPostScan.
func (tr *nxNull{{ $camelName }}) Ordinary() *{{ $camelName }} {
  return tr.ordinary
}

func (slice *{{ $camelName }}Slice) nxLen() int {
  return len(*slice)
}

func (slice *{{ $camelName }}Slice) nxItem(i int) interface{} {
  return (*slice)[i]
}

func (slice *{{ $camelName }}Slice) nxAppend(item interface{}) {
  if item == nil {
    *slice = append(*slice, &{{ $camelName }}{})
  } else {
    *slice = append(*slice, item.(*{{ $camelName }}))
  }
}

// Suppress not used errors.
var (
  _ = context.Background
  _ = fmt.Printf
  _ = strings.Join
  _ = time.Now
  _ = sql.Drivers
  _ = null.NewBool
)

var (
  _ TableRow = (*{{ $camelName }})(nil)
  {{ if $primary.Valid -}}
    _ TableRowWithPrimary = (*{{ $camelName }})(nil)
  {{ end -}}
  _ ColumnScanner = (*nxNull{{ $camelName }})(nil)
  _ Slicer = (*{{ $camelName }}Slice)(nil)
)
