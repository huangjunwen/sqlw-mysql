// Auto generated by sqlw-mysql (https://github.com/huangjunwen/sqlw-mysql) default template.
// DON NOT EDIT.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"gopkg.in/volatiletech/null.v6"
)

// User represents a row of table `user`.
type User struct {
	Id       int32     `json:"id" db:"id"`
	Name     string    `json:"name" db:"name"`
	Female   null.Bool `json:"female" db:"female"`
	Birthday null.Time `json:"birthday" db:"birthday"`
}

// nxUserPrimaryValue is the primary value of User.
type nxUserPrimaryValue struct {
	Id int32
}

// nxNullUser is nullable version of User.
// It's mainly used for scanning row which maybe NULL (e.g. in outer join).
type nxNullUser struct {
	ordinary *User
	nxUser   User
	nullId   null.Int32  // For scanning column `id`
	nullName null.String // For scanning column `name`
}

// UserSlice is slice of User.
type UserSlice []*User

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *User) nxPreScan(dest *[]interface{}) {
	*dest = append(*dest,
		&tr.Id,
		&tr.Name,
		&tr.Female,
		&tr.Birthday,
	)
}

// nxPostScan do nothing. Implements ColumnScanner interface.
func (tr *User) nxPostScan() error {
	return nil
}

var (
	nxUserMeta = NewTableMeta(
		"user",
		[]string{"id", "name", "female", "birthday"},
		OptColumnsWithDefault("id"),
		OptPrimaryColumns("id"),
		OptAutoIncColumn("id"),
	)
)

// TableMeta returns the table meta information of table `user`. Implements TableRow interface.
func (tr *User) TableMeta() *TableMeta {
	return nxUserMeta
}

// Valid returns true if this is a valid table row (e.g. not NULL). Implements TableRow interface.
func (tr *User) Valid() bool {
	return tr != nil
}

// ColumnValue returns the i-th column's value. Implements TableRow interface.
func (tr *User) ColumnValue(i int) interface{} {
	switch i {
	case 0:
		return tr.Id
	case 1:
		return tr.Name
	case 2:
		return tr.Female
	case 3:
		return tr.Birthday
	default:
		panic(fmt.Errorf("User.ColumnValue: %d out of range", i))
	}
}

// ColumnPointer returns the i-th column's pointer. Implements TableRow interface.
func (tr *User) ColumnPointer(i int) interface{} {
	switch i {
	case 0:
		return &tr.Id
	case 1:
		return &tr.Name
	case 2:
		return &tr.Female
	case 3:
		return &tr.Birthday
	default:
		panic(fmt.Errorf("User.ColumnPointer: %d out of range", i))
	}
}

// Copy the row.
func (tr *User) Copy() *User {
	ret := &User{}
	*ret = *tr
	return ret
}

// PrimaryValue returns the primary key value of this row. Implements TableRowWithPrimary interface.
func (tr *User) PrimaryValue() interface{} {
	if tr == nil {
		return nil
	}
	return nxUserPrimaryValue{
		Id: tr.Id,
	}
}

// Insert is used to insert the row into table.
// This method will also update the value in auto increment column (if exists).
func (tr *User) Insert(ctx context.Context, e Execer) error {
	return insertTR(ctx, e, tr, "")
}

// InsertEx is the same as Insert with extra modifier specified.
// modifier can be one of:
//   - "ignore": "INSERT IGNORE INTO ..."
//   - "replace": "REPLACE INTO ..."
//   - "": Normal "INSERT INTO ..."
func (tr *User) InsertEx(ctx context.Context, e Execer, modifier string) error {
	return insertTR(ctx, e, tr, modifier)
}

// Reload is used to reload the row from table. It returns error if no row is found.
func (tr *User) Reload(ctx context.Context, q Queryer) error {
	return selectTR(ctx, q, tr, false)
}

// ReloadWithLock is used to reload this row with lock from table. It returns error if no row is found.
func (tr *User) ReloadWithLock(ctx context.Context, q Queryer) error {
	return selectTR(ctx, q, tr, true)
}

// Update is used to update the row in table. Only columns with different values will be updated.
// NOTE: This method does not modify content in `tr`/`newTr`. Use Reload to load fresh data from database.
func (tr *User) Update(ctx context.Context, e Execer, newTr *User) error {
	return updateTR(ctx, e, tr, newTr)
}

// Delete is used to delete the row from table.
func (tr *User) Delete(ctx context.Context, e Execer) error {
	return deleteTR(ctx, e, tr)
}

// UserByPrimary is used to select User by `PRIMARY` index.
// It returns nil if no row is found.
func UserByPrimary(ctx context.Context, q Queryer, nxId int32, lock bool) (*User, error) {
	tr := User{}
	if err := selectTRCond(ctx, q, &tr, lock, "1 AND `id`=?", nxId); err != nil {
		if err == sql.ErrNoRows {
			err = nil
		}
		return nil, err
	}
	return &tr, nil
}

// nxPreScan appends all columns to dest for scanning. Implements ColumnScanner interface.
func (tr *nxNullUser) nxPreScan(dest *[]interface{}) {
	*dest = append(*dest,
		&tr.nullId,
		&tr.nullName,
		&tr.nxUser.Female,
		&tr.nxUser.Birthday,
	)
}

// nxPostScan must be called after scanning to do some extra processsing. Implements ColumnScanner interface.
func (tr *nxNullUser) nxPostScan() error {

	var nullCol string

	if !tr.nullId.Valid {
		nullCol = "id"
		goto CheckNULL
	}
	tr.nxUser.Id = tr.nullId.Int32

	if !tr.nullName.Valid {
		nullCol = "name"
		goto CheckNULL
	}
	tr.nxUser.Name = tr.nullName.String

	if false {
		// NOTE: Impossible branch to suppress "label CheckNULL defined and not used" error.
		goto CheckNULL
	}

	// All checks passed
	tr.ordinary = &tr.nxUser
	return nil

CheckNULL:
	if *tr == (nxNullUser{}) {
		// Null row, set ptr to nil.
		tr.ordinary = nil
		return nil
	}
	return fmt.Errorf("user.%s can't be NULL", nullCol)
}

// Ordinary returns the ordinary User. It must be called only after nxPostScan.
func (tr *nxNullUser) Ordinary() *User {
	return tr.ordinary
}

func (slice *UserSlice) nxLen() int {
	return len(*slice)
}

func (slice *UserSlice) nxItem(i int) interface{} {
	return (*slice)[i]
}

func (slice *UserSlice) nxAppend(item interface{}) {
	if item == nil {
		*slice = append(*slice, &User{})
	} else {
		*slice = append(*slice, item.(*User))
	}
}

// Suppress not used errors.
var (
	_ = context.Background
	_ = fmt.Printf
	_ = strings.Join
	_ = time.Now
	_ = sql.Drivers
	_ = null.NewBool
)

var (
	_ TableRow            = (*User)(nil)
	_ TableRowWithPrimary = (*User)(nil)
	_ ColumnScanner       = (*nxNullUser)(nil)
	_ Slicer              = (*UserSlice)(nil)
)
